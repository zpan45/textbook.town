---
layout: default
title: {{ site.name }}
---

<div id="analysis">
  <body>
	<h1>Project Retrospective</h1>
    
    <h2>Workflow</h2>
	  <p>The branching model we used on GitHub is very simple. 
		  We pulled the files we need from dev branch, and worked on individual tasks on separate branches 
		  (we had branches for each subtask like back-search, owner-bids, login, etc.). After testing the completed subtask code to 
		  ensure there were no bugs, the subtask code was merged into the dev branch. When it was time to submit a deliverable, dev was merged into master.</p>
	  
	  <p>Our group used many development tools/frameworks. For back-end, we used Python-Flask with a MySQL database. For front-end, we used HTML, CSS, JavaScript JQuery, and Mustache rendering system. 
		  All exchanges are made through REST API for extensibility.</p>
	  
	  <p>Our team managed task distribution effectively. We usually discussed about the distribution at the beginning of every
		  stage during our group meeting, and updated the details on Trello. However, itâ€™s super different to ensure that the work
		  assigned to each person is balanced. This is because each member had different levels of programming experience;
		  some of us were already familiar with the languages we used, but some of us has no experience. In conclusion, although we 
		  could not ensure everyone had same amount of work, the team still communicated and distributed the work well.</p>
    
    <h2>MVC / Design Patterns</h2>
	  <p>We implemented our server-side program as a REST API using Python-Flask. Our model classes are User, Textbook, Bid, and Auction. 
		  Using SQLAlchemy (our database ORM), these model classes were implemented as subclasses of SQLAlchemy's db.Model.
		  With Flask and Python, the MVC controllers did not need to be in classes. Instead, they were a collection of functions (known as app routes),
		  which were mapped to URLs. The view portion of our MVC design was implemented through HTML, CSS, and Javascript files.	
	  </p>
	  <p>The MVC communication protocol is as follows: When a user performs an action on the front-end (like clicking a button, or navigating to a new page),
		  the front-end sends a request, over REST, to the appropriate app route on the back-end. This app route function performs the necessary manipulations
		  to one of the model classes, and updates the database. The app route then sends a JSON response, over REST, back to the front-end.
	  </p>
	  <p>Overall, we believe our code organization was good. The one thing we would consider reorganizing is our back-end file structure.
		  Our main backend file (api.py) is quite long. Although this wasn't an issue for the project at its current scale,
		  it might have been a good idea to modularize the back-end code further for ease of maintenance.
	  </p>
    
    <h2>Refactor Retrospective</h2>
	  <p>Overall, we believe the code for our project very strong. We went through several refactoring iterations during the project,
		  which really diminshed the "dark corners" to talk about in this retrospective. The positives of our program include:
		  A strong templating engine to make pages modular and malleable; a consistent and well-documented API; and not using Grails 
		  for our backend. Some things we could have done better: a more elegent solution could have been found for HTML imports, and 
		  we could have solved the "pyramid of death" in our javascript.		   
	  </p>
	  <p> Our modular, template-based front-end really sped up development. It also helped people separate their code from each other,
		  which reduced git conflicts. It was also very helpful to have a template library to look at and use as a starting point for developing new pages or HTML elements. Additionally, the API document made setting up endpoints on both sides of the project very simple--we could simply add a form or JSON format to the API document, and everyone working on the feature could work independently on implementation without
		  needing to wait for the opposite team. Not using Grails was great because it allowed us to complete our project. We needed to pass multiple files over REST, and using Flask allowed us to easily deal with multipart/form-data to accomplish this. On the backend, separating our Textbook and Auction classes allowed us to isolate the textbook itself from the auction for it. Having different objects for these things helped clarify the way our backend logic was to be implemented.
          </p>
	  <p> Most of our unsolved coding problems are more "cobwebby" corners than dark ones--features that are functional, but a little messy. We could have cleaned them up with more time or effort, but they were low priority and thus snuck into the final build. The problem on every document on the front end is the large header area. We tried to import this from its own document early on in the project, but many browsers dont allow for HTML importing. Although there are several available third-party javascript libraries that implement this feature, but we decided that implementing a third party library was not a valuable use of our time. Currently, in changing the header, an edit would have to be added to every page manually. A third-party library would have allowed us to condense our giant header text into one import line, and would have made editing the site-wide header information painless. There are also several solutions to the "pyramid of death" floating around on the internet, but again, since our implementation was functional, we decided not to fix it. There is really only one egregious example of a "pyramid of death" in our javascript, and as far as "pyramids of death" go, it isn't that bad. Leaving the "pyramid of death" in also allowed our developers to do the Dr. Evil finger quotes whenever talking about the "pyramid of death" or about our website in general. After all, every cloud has a silver lining.
	  
		  

    
    <h2>Project Retrospective</h2>
		<p>Our group communicated well with each other. Tasks were divided up evenly among members and each 
		person knew what they needed to complete. Deadlines were set and met by the group. If any member 
		struggled with a task, other members would help resolve any issues.</p>
		
		<p>The group could have worked more quickly and efficiently if more people were experienced with the 
		Python Flask backend system. It was challenging for members to learn this system and not much time was 
		available to truly learn and understand how it functions. It may have been better to have chosen
		a system that was easier to learn and apply (if such a system was available).</p>
		
		<p>It was interesting to see how a static webpage can be changed to a dynamic one through the use
		of Javascript functions. The elements of the webpage were more engaging and interacted better with
		the user. The Mustache rendering system used worked well across multiple pages and produced good 
		renders of the graphical elements. 
		
		<p>In an organizational perspective, the Trello site used to keep track of tasks was productive to the 
		project. All members could view the specific tasks that were assigned to them and monitor the progress
		of the group in general. It was a great tool to use.</p> 
		
		<p>The most troubling and challenging tool used in the project was Github. It was frustrating when 
		branches were merged together and conflicts occurred. It took a while to find the errors and fix them
		so that merging could be done successfully.</p>

  </body>  
</div>
