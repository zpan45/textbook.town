---
layout: default
title: {{ site.name }}
---

<div id="analysis">
  <body>
	<h1>Project Retrospective</h1>
    
    <h2>Workflow</h2>
	  <p>The branching model we used on GitHub is very simple. 
		  We pulled the files we need from dev branch, and worked on individual tasks on separate branches 
		  (we had branches for each subtask like back-search, owner-bids, login, etc.). After testing the completed subtask code to 
		  ensure there were no bugs, the subtask code was merged into the dev branch. When it was time to submit a deliverable, dev was merged into master.</p>
	  
	  <p>Our group used many development tools/frameworks. For back-end, we used Python-Flask with a MySQL database. For front-end, we used HTML, CSS, JavaScript JQuery, and Mustache rendering system. 
		  All exchanges are made through REST API for extensibility.</p>
	  
	  <p>Our team managed task distribution effectively. We usually discussed about the distribution at the beginning of every
		  stage during our group meeting, and updated the details on Trello. However, itâ€™s super different to ensure that the work
		  assigned to each person is balanced. This is because each member had different levels of programming experience;
		  some of us were already familiar with the languages we used, but some of us has no experience. In conclusion, although we 
		  could not ensure everyone had same amount of work, the team still communicated and distributed the work well.</p>
    
    <h2>MVC / Design Patterns</h2>
	  <p>We implemented our server-side program as a REST API using Python-Flask. Our model classes are User, Textbook, Bid, and Auction. 
		  Using SQLAlchemy (our database ORM), these model classes were implemented as subclasses of SQLAlchemy's db.Model.
		  With Flask and Python, the MVC controllers did not need to be in classes. Instead, they were a collection of functions (known as app routes),
		  which were mapped to URLs. The view portion of our MVC design was implemented through HTML, CSS, and Javascript files.	
	  </p>
	  <p>The MVC communication protocol is as follows: When a user performs an action on the front-end (like clicking a button, or navigating to a new page),
		  the front-end sends a request, over REST, to the appropriate app route on the back-end. This app route function performs the necessary manipulations
		  to one of the model classes, and updates the database. The app route then sends a JSON response, over REST, back to the front-end.
	  </p>
	  <p>Overall, we believe our code organization was good. The one thing we would consider reorganizing is our back-end file structure.
		  Our main backend file (api.py) is quite long. Although this wasn't an issue for the project at its current scale,
		  it might have been a good idea to modularize the back-end code further for ease of maintenance.
	  </p>
    
    <h2>Refactor Retrospective</h2>
    
    <h2>Project Retrospective</h2>
		<p>Our group communicated well with each other. Tasks were divided up evenly among members and each 
		person knew what they needed to complete. Deadlines were set and met by the group. If any member 
		struggled with a task, other members would help resolve any issues.</p>
		
		<p>The group could have worked more quickly and efficiently if more people were experienced with the 
		Python Flask backend system. It was challenging for members to learn this system and not much time was 
		available to truly learn and understand how it functions. It may have been better to have chosen
		a system that was easier to learn and apply (if such a system was available).</p>
		
		<p>It was interesting to see how a static webpage can be changed to a dynamic one through the use
		of Javascript functions. The elements of the webpage were more engaging and interacted better with
		the user. The Mustache rendering system used worked well across multiple pages and produced good 
		renders of the graphical elements. 
		
		<p>In an organizational perspective, the Trello site used to keep track of tasks was productive to the 
		project. All members could view the specific tasks that were assigned to them and monitor the progress
		of the group in general. It was a great tool to use.</p> 
		
		<p>The most troubling and challenging tool used in the project was Github. It was frustrating when 
		branches were merged together and conflicts occurred. It took a while to find the errors and fix them
		so that merging could be done successfully.</p>

  </body>  
</div>
