---
layout: default
title: {{ site.name }}
---

<div id="analysis">
  <body>
	<h1>Project Retrospective</h1>
    
    <h2>Workflow</h2>
	  <p>The branching model we used on GitHub is very simple. 
		  We pulled the files we need from dev branch, and worked on individual tasks on separate branches 
		  (we had branches for each subtask like back-search, owner-bids, login, etc.). After testing the completed subtask code to 
		  ensure there were no bugs, the subtask code was merged into the dev branch. When it was time to submit a deliverable, dev was merged into master.</p>
	  
	  <p>Our group used many development tools/frameworks. For back-end, we used Python-Flask with a MySQL database. For front-end, we used HTML, CSS, JavaScript JQuery, and Mustache rendering system. 
		  All exchanges are made through REST API for extensibility.</p>
	  
	  <p>Our team managed task distribution effectively. We usually discussed about the distribution at the beginning of every
		  stage during our group meeting, and updated the details on Trello. However, itâ€™s super different to ensure that the work
		  assigned to each person is balanced. This is because each member had different levels of programming experience;
		  some of us were already familiar with the languages we used, but some of us has no experience. In conclusion, although we 
		  could not ensure everyone had same amount of work, the team still communicated and distributed the work well.</p>
    
    <h2>MVC / Design Patterns</h2>
	  <p>We implemented our server-side program as a REST API using Python-Flask. Our model classes are User, Textbook, Bid, and Auction. 
		  Using SQLAlchemy (our database ORM), these model classes were implemented as subclasses of SQLAlchemy's db.Model.
		  With Flask and Python, the MVC controllers did not need to be in classes. Instead, they were a collection of functions (known as app routes),
		  which were mapped to URLs. The view portion of our MVC design was implemented through HTML, CSS, and Javascript files.	
	  </p>
	  <p>The MVC communication protocol is as follows: When a user performs an action on the front-end (like clicking a button, or navigating to a new page),
		  the front-end sends a request, over REST, to the appropriate app route on the back-end. This app route function performs the necessary manipulations
		  to one of the model classes, and updates the database. The app route then sends a JSON response, over REST, back to the front-end.
	  </p>
	  <p>Overall, we believe our code organization was good. The one thing we would consider reorganizing is our back-end file structure.
		  Our main backend file (api.py) is quite long. Although this wasn't an issue for the project at its current scale,
		  it might have been a good idea to modularize the back-end code further for ease of maintenance.
	  </p>
    
    <h2>Refactor Retrospective</h2>
	  <p>The code for our project was overall very strong, we went through several refactoring iterations during the project
		  which really diminshes the "dark corners" to talk about in this retrospective. The positives of our program include:
		  A strong templating engine to make pages modular and malleable, A consistent and well documented API, and not using grails 
		  for our backend. Some things we could have done better: a more elegent solution could have been found for html imports, and 
		  we could have solved the "pyramid of death" in our javascript.		   
	  </p>
	  <p> Our modular, template based front end really sped up development, and it also helped people serperate their code from each other
		  which really reduced conflicts in git. It was also really helpful to have a template library to look at when developing new templates
		  or pages for peices you could use as a starting point. The API document also made setting up endpoints on both sides of the project very simple,
		  we could simply add a form or JSON format to the API document, and everyone working on the feature could work independantly on implementation without
		  needing to wait for the heads up from their other number on the opposite team. Not using GRAILS was great because it allowed us to complete our project.
          </p>
	  <p> Most of our unsolved coding problems are more cobwebby corners then dark ones. Features that are functional, but a little messy. We could have cleaned them up
		  with more time or effort, but they were low priority and thus snuck into the final build. The problem that we will see on every document on the front end
		  is the large header area, we tried to import this from its own document early on in the project, but many browsers dont allow for html importing, there are 
		  several available third party javascript libraries that implement this feature, but we decided that implementing a third party library was not in the budget. 
		  This library would have allowed us to condese our giant header text into one import line, and would have made editing the header information site wide painless,
		  currently an edit would have to be added to every page manually. There is also several solution to the "pyramid of death" floating around the internet, but once again
		  since it wasn't broke, we diddn't fix it. There is also only one very egregious example of "pyramid of death" in our javascript, and as far as "pyramids of death" go, its
		  not even that bad. Leaving the "pyramid of death" in, also allowed our developers to do the Dr. Evil finger qoutes whenever talking about the "pyramid of death" or our website
		  in general. Every cloud has a silver lining after all.
	  
		  

    
    <h2>Project Retrospective</h2>
		<p>Our group communicated well with each other. Tasks were divided up evenly among members and each 
		person knew what they needed to complete. Deadlines were set and met by the group. If any member 
		struggled with a task, other members would help resolve any issues.</p>
		
		<p>The group could have worked more quickly and efficiently if more people were experienced with the 
		Python Flask backend system. It was challenging for members to learn this system and not much time was 
		available to truly learn and understand how it functions. It may have been better to have chosen
		a system that was easier to learn and apply (if such a system was available).</p>
		
		<p>It was interesting to see how a static webpage can be changed to a dynamic one through the use
		of Javascript functions. The elements of the webpage were more engaging and interacted better with
		the user. The Mustache rendering system used worked well across multiple pages and produced good 
		renders of the graphical elements. 
		
		<p>In an organizational perspective, the Trello site used to keep track of tasks was productive to the 
		project. All members could view the specific tasks that were assigned to them and monitor the progress
		of the group in general. It was a great tool to use.</p> 
		
		<p>The most troubling and challenging tool used in the project was Github. It was frustrating when 
		branches were merged together and conflicts occurred. It took a while to find the errors and fix them
		so that merging could be done successfully.</p>

  </body>  
</div>
